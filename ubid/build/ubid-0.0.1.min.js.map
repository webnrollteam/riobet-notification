{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/async/lib/async.js","node_modules/browserify/node_modules/process/browser.js","node_modules/localforage/node_modules/promise/core.js","node_modules/localforage/node_modules/promise/index.js","node_modules/localforage/node_modules/promise/node_modules/asap/asap.js","node_modules/localforage/src/drivers/indexeddb.js","node_modules/localforage/src/drivers/localstorage.js","node_modules/localforage/src/drivers/websql.js","node_modules/localforage/src/localforage.js","node_modules/uuid/rng-browser.js","node_modules/uuid/uuid.js","index.js"],"names":[],"mappings":"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","file":"ubid-0.0.1.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function (process){\n/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n/*jshint onevar: false, indent:4 */\n/*global setImmediate: false, setTimeout: false, console: false */\n(function () {\n\n    var async = {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    root = this;\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        }\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n        if (arr.forEach) {\n            return arr.forEach(iterator);\n        }\n        for (var i = 0; i < arr.length; i += 1) {\n            iterator(arr[i], i, arr);\n        }\n    };\n\n    var _map = function (arr, iterator) {\n        if (arr.map) {\n            return arr.map(iterator);\n        }\n        var results = [];\n        _each(arr, function (x, i, a) {\n            results.push(iterator(x, i, a));\n        });\n        return results;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        if (arr.reduce) {\n            return arr.reduce(iterator, memo);\n        }\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _keys = function (obj) {\n        if (Object.keys) {\n            return Object.keys(obj);\n        }\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = function () {};\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || function () {};\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = Array.prototype.slice.call(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = function () {};\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = function () {};\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || function () {};\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = function () {};\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = function () {};\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        }\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || function () {};\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = function () {};\n                }\n                else {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || function () {};\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = Array.prototype.slice.call(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = Array.prototype.slice.call(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(Array.prototype.slice.call(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = Array.prototype.slice.call(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n                q.process();\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                q.process();\n            }\n        };\n        return q;\n    };\n    \n    async.priorityQueue = function (worker, concurrency) {\n        \n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        };\n        \n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n        \n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length == 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n              \n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n        \n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n        \n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n        \n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number'\n                            ? tasks.splice(0, payload)\n                            : tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = Array.prototype.slice.call(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = Array.prototype.slice.call(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = arguments;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = Array.prototype.slice.call(arguments, 1);\n                    cb(err, nextargs);\n                }]))\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = Array.prototype.slice.call(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = Array.prototype.slice.call(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n}).call(this,require('_process'))","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n","'use strict';\n\nvar asap = require('asap')\n\nmodule.exports = Promise\nfunction Promise(fn) {\n  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')\n  if (typeof fn !== 'function') throw new TypeError('not a function')\n  var state = null\n  var value = null\n  var deferreds = []\n  var self = this\n\n  this.then = function(onFulfilled, onRejected) {\n    return new Promise(function(resolve, reject) {\n      handle(new Handler(onFulfilled, onRejected, resolve, reject))\n    })\n  }\n\n  function handle(deferred) {\n    if (state === null) {\n      deferreds.push(deferred)\n      return\n    }\n    asap(function() {\n      var cb = state ? deferred.onFulfilled : deferred.onRejected\n      if (cb === null) {\n        (state ? deferred.resolve : deferred.reject)(value)\n        return\n      }\n      var ret\n      try {\n        ret = cb(value)\n      }\n      catch (e) {\n        deferred.reject(e)\n        return\n      }\n      deferred.resolve(ret)\n    })\n  }\n\n  function resolve(newValue) {\n    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')\n      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {\n        var then = newValue.then\n        if (typeof then === 'function') {\n          doResolve(then.bind(newValue), resolve, reject)\n          return\n        }\n      }\n      state = true\n      value = newValue\n      finale()\n    } catch (e) { reject(e) }\n  }\n\n  function reject(newValue) {\n    state = false\n    value = newValue\n    finale()\n  }\n\n  function finale() {\n    for (var i = 0, len = deferreds.length; i < len; i++)\n      handle(deferreds[i])\n    deferreds = null\n  }\n\n  doResolve(fn, resolve, reject)\n}\n\n\nfunction Handler(onFulfilled, onRejected, resolve, reject){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null\n  this.resolve = resolve\n  this.reject = reject\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, onFulfilled, onRejected) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return\n      done = true\n      onFulfilled(value)\n    }, function (reason) {\n      if (done) return\n      done = true\n      onRejected(reason)\n    })\n  } catch (ex) {\n    if (done) return\n    done = true\n    onRejected(ex)\n  }\n}\n","'use strict';\n\n//This file contains then/promise specific extensions to the core promise API\n\nvar Promise = require('./core.js')\nvar asap = require('asap')\n\nmodule.exports = Promise\n\n/* Static Functions */\n\nfunction ValuePromise(value) {\n  this.then = function (onFulfilled) {\n    if (typeof onFulfilled !== 'function') return this\n    return new Promise(function (resolve, reject) {\n      asap(function () {\n        try {\n          resolve(onFulfilled(value))\n        } catch (ex) {\n          reject(ex);\n        }\n      })\n    })\n  }\n}\nValuePromise.prototype = Object.create(Promise.prototype)\n\nvar TRUE = new ValuePromise(true)\nvar FALSE = new ValuePromise(false)\nvar NULL = new ValuePromise(null)\nvar UNDEFINED = new ValuePromise(undefined)\nvar ZERO = new ValuePromise(0)\nvar EMPTYSTRING = new ValuePromise('')\n\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value\n\n  if (value === null) return NULL\n  if (value === undefined) return UNDEFINED\n  if (value === true) return TRUE\n  if (value === false) return FALSE\n  if (value === 0) return ZERO\n  if (value === '') return EMPTYSTRING\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value))\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex)\n      })\n    }\n  }\n\n  return new ValuePromise(value)\n}\n\nPromise.from = Promise.cast = function (value) {\n  var err = new Error('Promise.from and Promise.cast are deprecated, use Promise.resolve instead')\n  err.name = 'Warning'\n  console.warn(err.stack)\n  return Promise.resolve(value)\n}\n\nPromise.denodeify = function (fn, argumentCount) {\n  argumentCount = argumentCount || Infinity\n  return function () {\n    var self = this\n    var args = Array.prototype.slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      while (args.length && args.length > argumentCount) {\n        args.pop()\n      }\n      args.push(function (err, res) {\n        if (err) reject(err)\n        else resolve(res)\n      })\n      fn.apply(self, args)\n    })\n  }\n}\nPromise.nodeify = function (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null\n    try {\n      return fn.apply(this, arguments).nodeify(callback)\n    } catch (ex) {\n      if (callback === null || typeof callback == 'undefined') {\n        return new Promise(function (resolve, reject) { reject(ex) })\n      } else {\n        asap(function () {\n          callback(ex)\n        })\n      }\n    }\n  }\n}\n\nPromise.all = function () {\n  var calledWithArray = arguments.length === 1 && Array.isArray(arguments[0])\n  var args = Array.prototype.slice.call(calledWithArray ? arguments[0] : arguments)\n\n  if (!calledWithArray) {\n    var err = new Error('Promise.all should be called with a single array, calling it with multiple arguments is deprecated')\n    err.name = 'Warning'\n    console.warn(err.stack)\n  }\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([])\n    var remaining = args.length\n    function res(i, val) {\n      try {\n        if (val && (typeof val === 'object' || typeof val === 'function')) {\n          var then = val.then\n          if (typeof then === 'function') {\n            then.call(val, function (val) { res(i, val) }, reject)\n            return\n          }\n        }\n        args[i] = val\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex)\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i])\n    }\n  })\n}\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) { \n    reject(value);\n  });\n}\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) { \n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    })\n  });\n}\n\n/* Prototype Methods */\n\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  var self = arguments.length ? this.then.apply(this, arguments) : this\n  self.then(null, function (err) {\n    asap(function () {\n      throw err\n    })\n  })\n}\n\nPromise.prototype.nodeify = function (callback) {\n  if (typeof callback != 'function') return this\n\n  this.then(function (value) {\n    asap(function () {\n      callback(null, value)\n    })\n  }, function (err) {\n    asap(function () {\n      callback(err)\n    })\n  })\n}\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n}\n","(function (process){\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\n\n// linked list of tasks (single, with head node)\nvar head = {task: void 0, next: null};\nvar tail = head;\nvar flushing = false;\nvar requestFlush = void 0;\nvar isNodeJS = false;\n\nfunction flush() {\n    /* jshint loopfunc: true */\n\n    while (head.next) {\n        head = head.next;\n        var task = head.task;\n        head.task = void 0;\n        var domain = head.domain;\n\n        if (domain) {\n            head.domain = void 0;\n            domain.enter();\n        }\n\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function() {\n                   throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    flushing = false;\n}\n\nif (typeof process !== \"undefined\" && process.nextTick) {\n    // Node.js before 0.9. Note that some fake-Node environments, like the\n    // Mocha test runner, introduce a `process` global without a `nextTick`.\n    isNodeJS = true;\n\n    requestFlush = function () {\n        process.nextTick(flush);\n    };\n\n} else if (typeof setImmediate === \"function\") {\n    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        requestFlush = setImmediate.bind(window, flush);\n    } else {\n        requestFlush = function () {\n            setImmediate(flush);\n        };\n    }\n\n} else if (typeof MessageChannel !== \"undefined\") {\n    // modern browsers\n    // http://www.nonblocking.io/2011/06/windownexttick.html\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    requestFlush = function () {\n        channel.port2.postMessage(0);\n    };\n\n} else {\n    // old browsers\n    requestFlush = function () {\n        setTimeout(flush, 0);\n    };\n}\n\nfunction asap(task) {\n    tail = tail.next = {\n        task: task,\n        domain: isNodeJS && process.domain,\n        next: null\n    };\n\n    if (!flushing) {\n        flushing = true;\n        requestFlush();\n    }\n};\n\nmodule.exports = asap;\n\n\n}).call(this,require('_process'))","// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n(function() {\n    'use strict';\n\n    // Originally found in https://github.com/mozilla-b2g/gaia/blob/e8f624e4cc9ea945727278039b3bc9bcb9f8667a/shared/js/async_storage.js\n\n    // Promises!\n    var Promise = (typeof module !== 'undefined' && module.exports) ?\n                  require('promise') : this.Promise;\n\n    // Initialize IndexedDB; fall back to vendor-prefixed versions if needed.\n    var indexedDB = indexedDB || this.indexedDB || this.webkitIndexedDB ||\n                    this.mozIndexedDB || this.OIndexedDB ||\n                    this.msIndexedDB;\n\n    // If IndexedDB isn't available, we get outta here!\n    if (!indexedDB) {\n        return;\n    }\n\n    // Open the IndexedDB database (automatically creates one if one didn't\n    // previously exist), using any options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = {\n            db: null\n        };\n\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = options[i];\n            }\n        }\n\n        return new Promise(function(resolve, reject) {\n            var openreq = indexedDB.open(dbInfo.name, dbInfo.version);\n            openreq.onerror = function() {\n                reject(openreq.error);\n            };\n            openreq.onupgradeneeded = function() {\n                // First time setup: create an empty object store\n                openreq.result.createObjectStore(dbInfo.storeName);\n            };\n            openreq.onsuccess = function() {\n                dbInfo.db = openreq.result;\n                self._dbInfo = dbInfo;\n                resolve();\n            };\n        });\n    }\n\n    function getItem(key, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                              .objectStore(dbInfo.storeName);\n                var req = store.get(key);\n\n                req.onsuccess = function() {\n                    var value = req.result;\n                    if (value === undefined) {\n                        value = null;\n                    }\n\n                    resolve(value);\n                };\n\n                req.onerror = function() {\n                    reject(req.error);\n                };\n            }).catch(reject);\n        });\n\n        executeDeferedCallback(promise, callback);\n        return promise;\n    }\n\n    function setItem(key, value, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readwrite')\n                              .objectStore(dbInfo.storeName);\n\n                // The reason we don't _save_ null is because IE 10 does\n                // not support saving the `null` type in IndexedDB. How\n                // ironic, given the bug below!\n                // See: https://github.com/mozilla/localForage/issues/161\n                if (value === null) {\n                    value = undefined;\n                }\n\n                var req = store.put(value, key);\n                req.onsuccess = function() {\n                    // Cast to undefined so the value passed to\n                    // callback/promise is the same as what one would get out\n                    // of `getItem()` later. This leads to some weirdness\n                    // (setItem('foo', undefined) will return `null`), but\n                    // it's not my fault localStorage is our baseline and that\n                    // it's weird.\n                    if (value === undefined) {\n                        value = null;\n                    }\n\n                    resolve(value);\n                };\n                req.onerror = function() {\n                    reject(req.error);\n                };\n            }).catch(reject);\n        });\n\n        executeDeferedCallback(promise, callback);\n        return promise;\n    }\n\n    function removeItem(key, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readwrite')\n                              .objectStore(dbInfo.storeName);\n\n                // We use a Grunt task to make this safe for IE and some\n                // versions of Android (including those used by Cordova).\n                // Normally IE won't like `.delete()` and will insist on\n                // using `['delete']()`, but we have a build step that\n                // fixes this for us now.\n                var req = store.delete(key);\n                req.onsuccess = function() {\n                    resolve();\n                };\n\n                req.onerror = function() {\n                    reject(req.error);\n                };\n\n                // The request will be aborted if we've exceeded our storage\n                // space. In this case, we will reject with a specific\n                // \"QuotaExceededError\".\n                req.onabort = function(event) {\n                    var error = event.target.error;\n                    if (error === 'QuotaExceededError') {\n                        reject(error);\n                    }\n                };\n            }).catch(reject);\n        });\n\n        executeDeferedCallback(promise, callback);\n        return promise;\n    }\n\n    function clear(callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readwrite')\n                              .objectStore(dbInfo.storeName);\n                var req = store.clear();\n\n                req.onsuccess = function() {\n                    resolve();\n                };\n\n                req.onerror = function() {\n                    reject(req.error);\n                };\n            }).catch(reject);\n        });\n\n        executeDeferedCallback(promise, callback);\n        return promise;\n    }\n\n    function length(callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                              .objectStore(dbInfo.storeName);\n                var req = store.count();\n\n                req.onsuccess = function() {\n                    resolve(req.result);\n                };\n\n                req.onerror = function() {\n                    reject(req.error);\n                };\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function key(n, callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            if (n < 0) {\n                resolve(null);\n\n                return;\n            }\n\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                              .objectStore(dbInfo.storeName);\n\n                var advanced = false;\n                var req = store.openCursor();\n                req.onsuccess = function() {\n                    var cursor = req.result;\n                    if (!cursor) {\n                        // this means there weren't enough keys\n                        resolve(null);\n\n                        return;\n                    }\n\n                    if (n === 0) {\n                        // We have the first key, return it if that's what they\n                        // wanted.\n                        resolve(cursor.key);\n                    } else {\n                        if (!advanced) {\n                            // Otherwise, ask the cursor to skip ahead n\n                            // records.\n                            advanced = true;\n                            cursor.advance(n);\n                        } else {\n                            // When we get here, we've got the nth key.\n                            resolve(cursor.key);\n                        }\n                    }\n                };\n\n                req.onerror = function() {\n                    reject(req.error);\n                };\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function keys(callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var store = dbInfo.db.transaction(dbInfo.storeName, 'readonly')\n                              .objectStore(dbInfo.storeName);\n\n                var req = store.openCursor();\n                var keys = [];\n\n                req.onsuccess = function() {\n                    var cursor = req.result;\n\n                    if (!cursor) {\n                        resolve(keys);\n                        return;\n                    }\n\n                    keys.push(cursor.key);\n                    cursor.continue();\n                };\n\n                req.onerror = function() {\n                    reject(req.error);\n                };\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function executeCallback(promise, callback) {\n        if (callback) {\n            promise.then(function(result) {\n                callback(null, result);\n            }, function(error) {\n                callback(error);\n            });\n        }\n    }\n\n    function executeDeferedCallback(promise, callback) {\n        if (callback) {\n            promise.then(function(result) {\n                deferCallback(callback, result);\n            }, function(error) {\n                callback(error);\n            });\n        }\n    }\n\n    // Under Chrome the callback is called before the changes (save, clear)\n    // are actually made. So we use a defer function which wait that the\n    // call stack to be empty.\n    // For more info : https://github.com/mozilla/localForage/issues/175\n    // Pull request : https://github.com/mozilla/localForage/pull/178\n    function deferCallback(callback, result) {\n        if (callback) {\n            return setTimeout(function() {\n                return callback(null, result);\n            }, 0);\n        }\n    }\n\n    var asyncStorage = {\n        _driver: 'asyncStorage',\n        _initStorage: _initStorage,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('asyncStorage', function() {\n            return asyncStorage;\n        });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = asyncStorage;\n    } else {\n        this.asyncStorage = asyncStorage;\n    }\n}).call(window);\n","// If IndexedDB isn't available, we'll fall back to localStorage.\n// Note that this will have considerable performance and storage\n// side-effects (all data will be serialized on save and only data that\n// can be converted to a string via `JSON.stringify()` will be saved).\n(function() {\n    'use strict';\n\n    // Promises!\n    var Promise = (typeof module !== 'undefined' && module.exports) ?\n                  require('promise') : this.Promise;\n    var localStorage = null;\n\n    // If the app is running inside a Google Chrome packaged webapp, or some\n    // other context where localStorage isn't available, we don't use\n    // localStorage. This feature detection is preferred over the old\n    // `if (window.chrome && window.chrome.runtime)` code.\n    // See: https://github.com/mozilla/localForage/issues/68\n    try {\n        // If localStorage isn't available, we get outta here!\n        // This should be inside a try catch\n        if (!this.localStorage || !('setItem' in this.localStorage)) {\n            return;\n        }\n        // Initialize localStorage and create a variable to use throughout\n        // the code.\n        localStorage = this.localStorage;\n    } catch (e) {\n        return;\n    }\n\n    // Config the localStorage backend, using options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = {};\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = options[i];\n            }\n        }\n\n        dbInfo.keyPrefix = dbInfo.name + '/';\n\n        self._dbInfo = dbInfo;\n        return Promise.resolve();\n    }\n\n    var SERIALIZED_MARKER = '__lfsc__:';\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n    // OMG the serializations!\n    var TYPE_ARRAYBUFFER = 'arbf';\n    var TYPE_BLOB = 'blob';\n    var TYPE_INT8ARRAY = 'si08';\n    var TYPE_UINT8ARRAY = 'ui08';\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n    var TYPE_INT16ARRAY = 'si16';\n    var TYPE_INT32ARRAY = 'si32';\n    var TYPE_UINT16ARRAY = 'ur16';\n    var TYPE_UINT32ARRAY = 'ui32';\n    var TYPE_FLOAT32ARRAY = 'fl32';\n    var TYPE_FLOAT64ARRAY = 'fl64';\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH +\n                                        TYPE_ARRAYBUFFER.length;\n\n    // Remove all keys from the datastore, effectively destroying all data in\n    // the app's key/value store!\n    function clear(callback) {\n        var self = this;\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var keyPrefix = self._dbInfo.keyPrefix;\n\n                for (var i = localStorage.length - 1; i >= 0; i--) {\n                    var key = localStorage.key(i);\n\n                    if (key.indexOf(keyPrefix) === 0) {\n                        localStorage.removeItem(key);\n                    }\n                }\n\n                resolve();\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Retrieve an item from the store. Unlike the original async_storage\n    // library in Gaia, we don't modify return values at all. If a key's value\n    // is `undefined`, we pass that value to the callback function.\n    function getItem(key, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                try {\n                    var dbInfo = self._dbInfo;\n                    var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n                    // If a result was found, parse it from the serialized\n                    // string into a JS object. If result isn't truthy, the key\n                    // is likely undefined and we'll pass it straight to the\n                    // callback.\n                    if (result) {\n                        result = _deserialize(result);\n                    }\n\n                    resolve(result);\n                } catch (e) {\n                    reject(e);\n                }\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Same as localStorage's key() method, except takes a callback.\n    function key(n, callback) {\n        var self = this;\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var result;\n                try {\n                    result = localStorage.key(n);\n                } catch (error) {\n                    result = null;\n                }\n\n                // Remove the prefix from the key, if a key is found.\n                if (result) {\n                    result = result.substring(dbInfo.keyPrefix.length);\n                }\n\n                resolve(result);\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function keys(callback) {\n        var self = this;\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                var length = localStorage.length;\n                var keys = [];\n\n                for (var i = 0; i < length; i++) {\n                    if (localStorage.key(i).indexOf(dbInfo.keyPrefix) === 0) {\n                        keys.push(localStorage.key(i).substring(dbInfo.keyPrefix.length));\n                    }\n                }\n\n                resolve(keys);\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Supply the number of keys in the datastore to the callback function.\n    function length(callback) {\n        var self = this;\n        var promise = new Promise(function(resolve, reject) {\n            self.keys().then(function(keys) {\n                resolve(keys.length);\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Remove an item from the store, nice and simple.\n    function removeItem(key, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                localStorage.removeItem(dbInfo.keyPrefix + key);\n\n                resolve();\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Deserialize data we've inserted into a value column/field. We place\n    // special markers into our strings to mark them as encoded; this isn't\n    // as nice as a meta field, but it's the only sane thing we can do whilst\n    // keeping localStorage support intact.\n    //\n    // Oftentimes this will just deserialize JSON content, but if we have a\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\n    // some kind of arraybuffer/binary data/typed array out of the string.\n    function _deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0,\n            SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n        }\n\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH,\n                                   TYPE_SERIALIZED_MARKER_LENGTH);\n\n        // Fill the string into a ArrayBuffer.\n        // 2 bytes for each char.\n        var buffer = new ArrayBuffer(serializedString.length * 2);\n        var bufferView = new Uint16Array(buffer);\n        for (var i = serializedString.length - 1; i >= 0; i--) {\n            bufferView[i] = serializedString.charCodeAt(i);\n        }\n\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n            case TYPE_ARRAYBUFFER:\n                return buffer;\n            case TYPE_BLOB:\n                return new Blob([buffer]);\n            case TYPE_INT8ARRAY:\n                return new Int8Array(buffer);\n            case TYPE_UINT8ARRAY:\n                return new Uint8Array(buffer);\n            case TYPE_UINT8CLAMPEDARRAY:\n                return new Uint8ClampedArray(buffer);\n            case TYPE_INT16ARRAY:\n                return new Int16Array(buffer);\n            case TYPE_UINT16ARRAY:\n                return new Uint16Array(buffer);\n            case TYPE_INT32ARRAY:\n                return new Int32Array(buffer);\n            case TYPE_UINT32ARRAY:\n                return new Uint32Array(buffer);\n            case TYPE_FLOAT32ARRAY:\n                return new Float32Array(buffer);\n            case TYPE_FLOAT64ARRAY:\n                return new Float64Array(buffer);\n            default:\n                throw new Error('Unkown type: ' + type);\n        }\n    }\n\n    // Converts a buffer to a string to store, serialized, in the backend\n    // storage library.\n    function _bufferToString(buffer) {\n        var str = '';\n        var uint16Array = new Uint16Array(buffer);\n\n        try {\n            str = String.fromCharCode.apply(null, uint16Array);\n        } catch (e) {\n            // This is a fallback implementation in case the first one does\n            // not work. This is required to get the phantomjs passing...\n            for (var i = 0; i < uint16Array.length; i++) {\n                str += String.fromCharCode(uint16Array[i]);\n            }\n        }\n\n        return str;\n    }\n\n    // Serialize a value, afterwards executing a callback (which usually\n    // instructs the `setItem()` callback/promise to be executed). This is how\n    // we store binary data with localStorage.\n    function _serialize(value, callback) {\n        var valueString = '';\n        if (value) {\n            valueString = value.toString();\n        }\n\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (value.toString() === '[object ArrayBuffer]' ||\n                      value.buffer &&\n                      value.buffer.toString() === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n\n            if (value instanceof ArrayBuffer) {\n                buffer = value;\n                marker += TYPE_ARRAYBUFFER;\n            } else {\n                buffer = value.buffer;\n\n                if (valueString === '[object Int8Array]') {\n                    marker += TYPE_INT8ARRAY;\n                } else if (valueString === '[object Uint8Array]') {\n                    marker += TYPE_UINT8ARRAY;\n                } else if (valueString === '[object Uint8ClampedArray]') {\n                    marker += TYPE_UINT8CLAMPEDARRAY;\n                } else if (valueString === '[object Int16Array]') {\n                    marker += TYPE_INT16ARRAY;\n                } else if (valueString === '[object Uint16Array]') {\n                    marker += TYPE_UINT16ARRAY;\n                } else if (valueString === '[object Int32Array]') {\n                    marker += TYPE_INT32ARRAY;\n                } else if (valueString === '[object Uint32Array]') {\n                    marker += TYPE_UINT32ARRAY;\n                } else if (valueString === '[object Float32Array]') {\n                    marker += TYPE_FLOAT32ARRAY;\n                } else if (valueString === '[object Float64Array]') {\n                    marker += TYPE_FLOAT64ARRAY;\n                } else {\n                    callback(new Error('Failed to get type for BinaryArray'));\n                }\n            }\n\n            callback(marker + _bufferToString(buffer));\n        } else if (valueString === '[object Blob]') {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n\n            fileReader.onload = function() {\n                var str = _bufferToString(this.result);\n\n                callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n\n            fileReader.readAsArrayBuffer(value);\n        } else {\n            try {\n                callback(JSON.stringify(value));\n            } catch (e) {\n                window.console.error(\"Couldn't convert value into a JSON \" +\n                                     'string: ', value);\n\n                callback(e);\n            }\n        }\n    }\n\n    // Set a key's value and run an optional callback once the value is set.\n    // Unlike Gaia's implementation, the callback function is passed the value,\n    // in case you want to operate on that value only after you're sure it\n    // saved, or something like that.\n    function setItem(key, value, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                // Convert undefined values to null.\n                // https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }\n\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n\n                _serialize(value, function(value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        try {\n                            var dbInfo = self._dbInfo;\n                            localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        } catch (e) {\n                            // localStorage capacity exceeded.\n                            // TODO: Make this a specific error/event.\n                            if (e.name === 'QuotaExceededError' ||\n                                e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                                reject(e);\n                            }\n                        }\n\n                        resolve(originalValue);\n                    }\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function executeCallback(promise, callback) {\n        if (callback) {\n            promise.then(function(result) {\n                callback(null, result);\n            }, function(error) {\n                callback(error);\n            });\n        }\n    }\n\n    var localStorageWrapper = {\n        _driver: 'localStorageWrapper',\n        _initStorage: _initStorage,\n        // Default API, from Gaia/localStorage.\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('localStorageWrapper', function() {\n            return localStorageWrapper;\n        });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = localStorageWrapper;\n    } else {\n        this.localStorageWrapper = localStorageWrapper;\n    }\n}).call(window);\n","/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function() {\n    'use strict';\n\n    // Sadly, the best way to save binary data in WebSQL is Base64 serializing\n    // it, so this is how we store it to prevent very strange errors with less\n    // verbose ways of binary <-> string data storage.\n    var BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    // Promises!\n    var Promise = (typeof module !== 'undefined' && module.exports) ?\n                  require('promise') : this.Promise;\n\n    var openDatabase = this.openDatabase;\n\n    var SERIALIZED_MARKER = '__lfsc__:';\n    var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n    // OMG the serializations!\n    var TYPE_ARRAYBUFFER = 'arbf';\n    var TYPE_BLOB = 'blob';\n    var TYPE_INT8ARRAY = 'si08';\n    var TYPE_UINT8ARRAY = 'ui08';\n    var TYPE_UINT8CLAMPEDARRAY = 'uic8';\n    var TYPE_INT16ARRAY = 'si16';\n    var TYPE_INT32ARRAY = 'si32';\n    var TYPE_UINT16ARRAY = 'ur16';\n    var TYPE_UINT32ARRAY = 'ui32';\n    var TYPE_FLOAT32ARRAY = 'fl32';\n    var TYPE_FLOAT64ARRAY = 'fl64';\n    var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH +\n                                        TYPE_ARRAYBUFFER.length;\n\n    // If WebSQL methods aren't available, we can stop now.\n    if (!openDatabase) {\n        return;\n    }\n\n    // Open the WebSQL database (automatically creates one if one didn't\n    // previously exist), using any options set in the config.\n    function _initStorage(options) {\n        var self = this;\n        var dbInfo = {\n            db: null\n        };\n\n        if (options) {\n            for (var i in options) {\n                dbInfo[i] = typeof(options[i]) !== 'string' ?\n                            options[i].toString() : options[i];\n            }\n        }\n\n        return new Promise(function(resolve, reject) {\n            // Open the database; the openDatabase API will automatically\n            // create it for us if it doesn't exist.\n            try {\n                dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version),\n                                         dbInfo.description, dbInfo.size);\n            } catch (e) {\n                return self.setDriver('localStorageWrapper')\n                    .then(function() {\n                        return self._initStorage(options);\n                    })\n                    .then(resolve)\n                    .catch(reject);\n            }\n\n            // Create our key/value table if it doesn't exist.\n            dbInfo.db.transaction(function(t) {\n                t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName +\n                             ' (id INTEGER PRIMARY KEY, key unique, value)', [],\n                             function() {\n                    self._dbInfo = dbInfo;\n                    resolve();\n                }, function(t, error) {\n                    reject(error);\n                });\n            });\n        });\n    }\n\n    function getItem(key, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    t.executeSql('SELECT * FROM ' + dbInfo.storeName +\n                                 ' WHERE key = ? LIMIT 1', [key],\n                                 function(t, results) {\n                        var result = results.rows.length ?\n                                     results.rows.item(0).value : null;\n\n                        // Check to see if this is serialized content we need to\n                        // unpack.\n                        if (result) {\n                            result = _deserialize(result);\n                        }\n\n                        resolve(result);\n                    }, function(t, error) {\n\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function setItem(key, value, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                // The localStorage API doesn't return undefined values in an\n                // \"expected\" way, so undefined is always cast to null in all\n                // drivers. See: https://github.com/mozilla/localForage/pull/42\n                if (value === undefined) {\n                    value = null;\n                }\n\n                // Save the original value to pass to the callback.\n                var originalValue = value;\n\n                _serialize(value, function(value, error) {\n                    if (error) {\n                        reject(error);\n                    } else {\n                        var dbInfo = self._dbInfo;\n                        dbInfo.db.transaction(function(t) {\n                            t.executeSql('INSERT OR REPLACE INTO ' +\n                                         dbInfo.storeName +\n                                         ' (key, value) VALUES (?, ?)',\n                                         [key, value], function() {\n                                resolve(originalValue);\n                            }, function(t, error) {\n                                reject(error);\n                            });\n                        }, function(sqlError) { // The transaction failed; check\n                                                // to see if it's a quota error.\n                            if (sqlError.code === sqlError.QUOTA_ERR) {\n                                // We reject the callback outright for now, but\n                                // it's worth trying to re-run the transaction.\n                                // Even if the user accepts the prompt to use\n                                // more storage on Safari, this error will\n                                // be called.\n                                //\n                                // TODO: Try to re-run the transaction.\n                                reject(sqlError);\n                            }\n                        });\n                    }\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function removeItem(key, callback) {\n        var self = this;\n\n        // Cast the key to a string, as that's all we can set as a key.\n        if (typeof key !== 'string') {\n            window.console.warn(key +\n                                ' used as a key, but it is not a string.');\n            key = String(key);\n        }\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    t.executeSql('DELETE FROM ' + dbInfo.storeName +\n                                 ' WHERE key = ?', [key], function() {\n\n                        resolve();\n                    }, function(t, error) {\n\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Deletes every item in the table.\n    // TODO: Find out if this resets the AUTO_INCREMENT number.\n    function clear(callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    t.executeSql('DELETE FROM ' + dbInfo.storeName, [],\n                                 function() {\n                        resolve();\n                    }, function(t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Does a simple `COUNT(key)` to get the number of items stored in\n    // localForage.\n    function length(callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    // Ahhh, SQL makes this one soooooo easy.\n                    t.executeSql('SELECT COUNT(key) as c FROM ' +\n                                 dbInfo.storeName, [], function(t, results) {\n                        var result = results.rows.item(0).c;\n\n                        resolve(result);\n                    }, function(t, error) {\n\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Return the key located at key index X; essentially gets the key from a\n    // `WHERE id = ?`. This is the most efficient way I can think to implement\n    // this rarely-used (in my experience) part of the API, but it can seem\n    // inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n    // the ID of each key will change every time it's updated. Perhaps a stored\n    // procedure for the `setItem()` SQL would solve this problem?\n    // TODO: Don't change ID on `setItem()`.\n    function key(n, callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    t.executeSql('SELECT key FROM ' + dbInfo.storeName +\n                                 ' WHERE id = ? LIMIT 1', [n + 1],\n                                 function(t, results) {\n                        var result = results.rows.length ?\n                                     results.rows.item(0).key : null;\n                        resolve(result);\n                    }, function(t, error) {\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    function keys(callback) {\n        var self = this;\n\n        var promise = new Promise(function(resolve, reject) {\n            self.ready().then(function() {\n                var dbInfo = self._dbInfo;\n                dbInfo.db.transaction(function(t) {\n                    t.executeSql('SELECT key FROM ' + dbInfo.storeName, [],\n                                 function(t, results) {\n                        var keys = [];\n\n                        for (var i = 0; i < results.rows.length; i++) {\n                            keys.push(results.rows.item(i).key);\n                        }\n\n                        resolve(keys);\n                    }, function(t, error) {\n\n                        reject(error);\n                    });\n                });\n            }).catch(reject);\n        });\n\n        executeCallback(promise, callback);\n        return promise;\n    }\n\n    // Converts a buffer to a string to store, serialized, in the backend\n    // storage library.\n    function _bufferToString(buffer) {\n        // base64-arraybuffer\n        var bytes = new Uint8Array(buffer);\n        var i;\n        var base64String = '';\n\n        for (i = 0; i < bytes.length; i += 3) {\n            /*jslint bitwise: true */\n            base64String += BASE_CHARS[bytes[i] >> 2];\n            base64String += BASE_CHARS[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n            base64String += BASE_CHARS[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n            base64String += BASE_CHARS[bytes[i + 2] & 63];\n        }\n\n        if ((bytes.length % 3) === 2) {\n            base64String = base64String.substring(0, base64String.length - 1) + '=';\n        } else if (bytes.length % 3 === 1) {\n            base64String = base64String.substring(0, base64String.length - 2) + '==';\n        }\n\n        return base64String;\n    }\n\n    // Deserialize data we've inserted into a value column/field. We place\n    // special markers into our strings to mark them as encoded; this isn't\n    // as nice as a meta field, but it's the only sane thing we can do whilst\n    // keeping localStorage support intact.\n    //\n    // Oftentimes this will just deserialize JSON content, but if we have a\n    // special marker (SERIALIZED_MARKER, defined above), we will extract\n    // some kind of arraybuffer/binary data/typed array out of the string.\n    function _deserialize(value) {\n        // If we haven't marked this string as being specially serialized (i.e.\n        // something other than serialized JSON), we can just return it and be\n        // done with it.\n        if (value.substring(0,\n                            SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n            return JSON.parse(value);\n        }\n\n        // The following code deals with deserializing some kind of Blob or\n        // TypedArray. First we separate out the type of data we're dealing\n        // with from the data itself.\n        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n        var type = value.substring(SERIALIZED_MARKER_LENGTH,\n                                   TYPE_SERIALIZED_MARKER_LENGTH);\n\n        // Fill the string into a ArrayBuffer.\n        var bufferLength = serializedString.length * 0.75;\n        var len = serializedString.length;\n        var i;\n        var p = 0;\n        var encoded1, encoded2, encoded3, encoded4;\n\n        if (serializedString[serializedString.length - 1] === '=') {\n            bufferLength--;\n            if (serializedString[serializedString.length - 2] === '=') {\n                bufferLength--;\n            }\n        }\n\n        var buffer = new ArrayBuffer(bufferLength);\n        var bytes = new Uint8Array(buffer);\n\n        for (i = 0; i < len; i+=4) {\n            encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n            encoded2 = BASE_CHARS.indexOf(serializedString[i+1]);\n            encoded3 = BASE_CHARS.indexOf(serializedString[i+2]);\n            encoded4 = BASE_CHARS.indexOf(serializedString[i+3]);\n\n            /*jslint bitwise: true */\n            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n        }\n\n        // Return the right type based on the code/type set during\n        // serialization.\n        switch (type) {\n            case TYPE_ARRAYBUFFER:\n                return buffer;\n            case TYPE_BLOB:\n                return new Blob([buffer]);\n            case TYPE_INT8ARRAY:\n                return new Int8Array(buffer);\n            case TYPE_UINT8ARRAY:\n                return new Uint8Array(buffer);\n            case TYPE_UINT8CLAMPEDARRAY:\n                return new Uint8ClampedArray(buffer);\n            case TYPE_INT16ARRAY:\n                return new Int16Array(buffer);\n            case TYPE_UINT16ARRAY:\n                return new Uint16Array(buffer);\n            case TYPE_INT32ARRAY:\n                return new Int32Array(buffer);\n            case TYPE_UINT32ARRAY:\n                return new Uint32Array(buffer);\n            case TYPE_FLOAT32ARRAY:\n                return new Float32Array(buffer);\n            case TYPE_FLOAT64ARRAY:\n                return new Float64Array(buffer);\n            default:\n                throw new Error('Unkown type: ' + type);\n        }\n    }\n\n    // Serialize a value, afterwards executing a callback (which usually\n    // instructs the `setItem()` callback/promise to be executed). This is how\n    // we store binary data with localStorage.\n    function _serialize(value, callback) {\n        var valueString = '';\n        if (value) {\n            valueString = value.toString();\n        }\n\n        // Cannot use `value instanceof ArrayBuffer` or such here, as these\n        // checks fail when running the tests using casper.js...\n        //\n        // TODO: See why those tests fail and use a better solution.\n        if (value && (value.toString() === '[object ArrayBuffer]' ||\n                      value.buffer &&\n                      value.buffer.toString() === '[object ArrayBuffer]')) {\n            // Convert binary arrays to a string and prefix the string with\n            // a special marker.\n            var buffer;\n            var marker = SERIALIZED_MARKER;\n\n            if (value instanceof ArrayBuffer) {\n                buffer = value;\n                marker += TYPE_ARRAYBUFFER;\n            } else {\n                buffer = value.buffer;\n\n                if (valueString === '[object Int8Array]') {\n                    marker += TYPE_INT8ARRAY;\n                } else if (valueString === '[object Uint8Array]') {\n                    marker += TYPE_UINT8ARRAY;\n                } else if (valueString === '[object Uint8ClampedArray]') {\n                    marker += TYPE_UINT8CLAMPEDARRAY;\n                } else if (valueString === '[object Int16Array]') {\n                    marker += TYPE_INT16ARRAY;\n                } else if (valueString === '[object Uint16Array]') {\n                    marker += TYPE_UINT16ARRAY;\n                } else if (valueString === '[object Int32Array]') {\n                    marker += TYPE_INT32ARRAY;\n                } else if (valueString === '[object Uint32Array]') {\n                    marker += TYPE_UINT32ARRAY;\n                } else if (valueString === '[object Float32Array]') {\n                    marker += TYPE_FLOAT32ARRAY;\n                } else if (valueString === '[object Float64Array]') {\n                    marker += TYPE_FLOAT64ARRAY;\n                } else {\n                    callback(new Error('Failed to get type for BinaryArray'));\n                }\n            }\n\n            callback(marker + _bufferToString(buffer));\n        } else if (valueString === '[object Blob]') {\n            // Conver the blob to a binaryArray and then to a string.\n            var fileReader = new FileReader();\n\n            fileReader.onload = function() {\n                var str = _bufferToString(this.result);\n\n                callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n            };\n\n            fileReader.readAsArrayBuffer(value);\n        } else {\n            try {\n                callback(JSON.stringify(value));\n            } catch (e) {\n                window.console.error(\"Couldn't convert value into a JSON \" +\n                                     'string: ', value);\n\n                callback(null, e);\n            }\n        }\n    }\n\n    function executeCallback(promise, callback) {\n        if (callback) {\n            promise.then(function(result) {\n                callback(null, result);\n            }, function(error) {\n                callback(error);\n            });\n        }\n    }\n\n    var webSQLStorage = {\n        _driver: 'webSQLStorage',\n        _initStorage: _initStorage,\n        getItem: getItem,\n        setItem: setItem,\n        removeItem: removeItem,\n        clear: clear,\n        length: length,\n        key: key,\n        keys: keys\n    };\n\n    if (typeof define === 'function' && define.amd) {\n        define('webSQLStorage', function() {\n            return webSQLStorage;\n        });\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = webSQLStorage;\n    } else {\n        this.webSQLStorage = webSQLStorage;\n    }\n}).call(window);\n","(function() {\n    'use strict';\n\n    // Promises!\n    var Promise = (typeof module !== 'undefined' && module.exports) ?\n                  require('promise') : this.Promise;\n\n    // Custom drivers are stored here when `defineDriver()` is called.\n    // They are shared across all instances of localForage.\n    var CustomDrivers = {};\n\n    var DriverType = {\n        INDEXEDDB: 'asyncStorage',\n        LOCALSTORAGE: 'localStorageWrapper',\n        WEBSQL: 'webSQLStorage'\n    };\n\n    var DefaultDriverOrder = [\n        DriverType.INDEXEDDB,\n        DriverType.WEBSQL,\n        DriverType.LOCALSTORAGE\n    ];\n\n    var LibraryMethods = [\n        'clear',\n        'getItem',\n        'key',\n        'keys',\n        'length',\n        'removeItem',\n        'setItem'\n    ];\n\n    var ModuleType = {\n        DEFINE: 1,\n        EXPORT: 2,\n        WINDOW: 3\n    };\n\n    var DefaultConfig = {\n        description: '',\n        driver: DefaultDriverOrder.slice(),\n        name: 'localforage',\n        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n        // we can use without a prompt.\n        size: 4980736,\n        storeName: 'keyvaluepairs',\n        version: 1.0\n    };\n\n    // Attaching to window (i.e. no module loader) is the assumed,\n    // simple default.\n    var moduleType = ModuleType.WINDOW;\n\n    // Find out what kind of module setup we have; if none, we'll just attach\n    // localForage to the main window.\n    if (typeof define === 'function' && define.amd) {\n        moduleType = ModuleType.DEFINE;\n    } else if (typeof module !== 'undefined' && module.exports) {\n        moduleType = ModuleType.EXPORT;\n    }\n\n    // Check to see if IndexedDB is available and if it is the latest\n    // implementation; it's our preferred backend library. We use \"_spec_test\"\n    // as the name of the database because it's not the one we'll operate on,\n    // but it's useful to make sure its using the right spec.\n    // See: https://github.com/mozilla/localForage/issues/128\n    var driverSupport = (function(self) {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        var indexedDB = indexedDB || self.indexedDB || self.webkitIndexedDB ||\n                        self.mozIndexedDB || self.OIndexedDB ||\n                        self.msIndexedDB;\n\n        var result = {};\n\n        result[DriverType.WEBSQL] = !!self.openDatabase;\n        result[DriverType.INDEXEDDB] = !!(function() {\n            // We mimic PouchDB here; just UA test for Safari (which, as of\n            // iOS 8/Yosemite, doesn't properly support IndexedDB).\n            // IndexedDB support is broken and different from Blink's.\n            // This is faster than the test case (and it's sync), so we just\n            // do this. *SIGH*\n            // http://bl.ocks.org/nolanlawson/raw/c83e9039edf2278047e9/\n            //\n            // We test for openDatabase because IE Mobile identifies itself\n            // as Safari. Oh the lulz...\n            if (typeof self.openDatabase !== 'undefined' && self.navigator &&\n                self.navigator.userAgent &&\n                /Safari/.test(self.navigator.userAgent) &&\n                !/Chrome/.test(self.navigator.userAgent)) {\n                return false;\n            }\n            try {\n                return indexedDB &&\n                       typeof indexedDB.open === 'function' &&\n                       // Some Samsung/HTC Android 4.0-4.3 devices\n                       // have older IndexedDB specs; if this isn't available\n                       // their IndexedDB is too old for us to use.\n                       // (Replaces the onupgradeneeded test.)\n                       typeof self.IDBKeyRange !== 'undefined';\n            } catch (e) {\n                return false;\n            }\n        })();\n\n        result[DriverType.LOCALSTORAGE] = !!(function() {\n            try {\n                return (self.localStorage &&\n                        ('setItem' in self.localStorage) &&\n                        (self.localStorage.setItem));\n            } catch (e) {\n                return false;\n            }\n        })();\n\n        return result;\n    })(this);\n\n    var isArray = Array.isArray || function(arg) {\n        return Object.prototype.toString.call(arg) === '[object Array]';\n    };\n\n    function callWhenReady(localForageInstance, libraryMethod) {\n        localForageInstance[libraryMethod] = function() {\n            var _args = arguments;\n            return localForageInstance.ready().then(function() {\n                return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n            });\n        };\n    }\n\n    function extend() {\n        for (var i = 1; i < arguments.length; i++) {\n            var arg = arguments[i];\n\n            if (arg) {\n                for (var key in arg) {\n                    if (arg.hasOwnProperty(key)) {\n                        if (isArray(arg[key])) {\n                            arguments[0][key] = arg[key].slice();\n                        } else {\n                            arguments[0][key] = arg[key];\n                        }\n                    }\n                }\n            }\n        }\n\n        return arguments[0];\n    }\n\n    function isLibraryDriver(driverName) {\n        for (var driver in DriverType) {\n            if (DriverType.hasOwnProperty(driver) &&\n                DriverType[driver] === driverName) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    var globalObject = this;\n\n    function LocalForage(options) {\n        this._config = extend({}, DefaultConfig, options);\n        this._driverSet = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0; i < LibraryMethods.length; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n\n        this.setDriver(this._config.driver);\n    }\n\n    LocalForage.prototype.INDEXEDDB = DriverType.INDEXEDDB;\n    LocalForage.prototype.LOCALSTORAGE = DriverType.LOCALSTORAGE;\n    LocalForage.prototype.WEBSQL = DriverType.WEBSQL;\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n    LocalForage.prototype.config = function(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if (typeof(options) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" +\n                                 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof(options) === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n    LocalForage.prototype.defineDriver = function(driverObject, callback,\n                                                  errorCallback) {\n        var defineDriver = new Promise(function(resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error(\n                    'Custom driver not compliant; see ' +\n                    'https://mozilla.github.io/localForage/#definedriver'\n                );\n                var namingError = new Error(\n                    'Custom driver name already in use: ' + driverObject._driver\n                );\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n                if (isLibraryDriver(driverObject._driver)) {\n                    reject(namingError);\n                    return;\n                }\n\n                var customDriverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0; i < customDriverMethods.length; i++) {\n                    var customDriverMethod = customDriverMethods[i];\n                    if (!customDriverMethod ||\n                        !driverObject[customDriverMethod] ||\n                        typeof driverObject[customDriverMethod] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var supportPromise = Promise.resolve(true);\n                if ('_support'  in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        supportPromise = driverObject._support();\n                    } else {\n                        supportPromise = Promise.resolve(!!driverObject._support);\n                    }\n                }\n\n                supportPromise.then(function(supportResult) {\n                    driverSupport[driverName] = supportResult;\n                    CustomDrivers[driverName] = driverObject;\n                    resolve();\n                }, reject);\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        defineDriver.then(callback, errorCallback);\n        return defineDriver;\n    };\n\n    LocalForage.prototype.driver = function() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.ready = function(callback) {\n        var self = this;\n\n        var ready = new Promise(function(resolve, reject) {\n            self._driverSet.then(function() {\n                if (self._ready === null) {\n                    self._ready = self._initStorage(self._config);\n                }\n\n                self._ready.then(resolve, reject);\n            }).catch(reject);\n        });\n\n        ready.then(callback, callback);\n        return ready;\n    };\n\n    LocalForage.prototype.setDriver = function(drivers, callback,\n                                               errorCallback) {\n        var self = this;\n\n        if (typeof drivers === 'string') {\n            drivers = [drivers];\n        }\n\n        this._driverSet = new Promise(function(resolve, reject) {\n            var driverName = self._getFirstSupportedDriver(drivers);\n            var error = new Error('No available storage method found.');\n\n            if (!driverName) {\n                self._driverSet = Promise.reject(error);\n                reject(error);\n                return;\n            }\n\n            self._dbInfo = null;\n            self._ready = null;\n\n            if (isLibraryDriver(driverName)) {\n                // We allow localForage to be declared as a module or as a\n                // library available without AMD/require.js.\n                if (moduleType === ModuleType.DEFINE) {\n                    require([driverName], function(lib) {\n                        self._extend(lib);\n\n                        resolve();\n                    });\n\n                    return;\n                } else if (moduleType === ModuleType.EXPORT) {\n                    // Making it browserify friendly\n                    var driver;\n                    switch (driverName) {\n                        case self.INDEXEDDB:\n                            driver = require('./drivers/indexeddb');\n                            break;\n                        case self.LOCALSTORAGE:\n                            driver = require('./drivers/localstorage');\n                            break;\n                        case self.WEBSQL:\n                            driver = require('./drivers/websql');\n                    }\n\n                    self._extend(driver);\n                } else {\n                    self._extend(globalObject[driverName]);\n                }\n            } else if (CustomDrivers[driverName]) {\n                self._extend(CustomDrivers[driverName]);\n            } else {\n                self._driverSet = Promise.reject(error);\n                reject(error);\n                return;\n            }\n\n            resolve();\n        });\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n        this._driverSet.then(setDriverToConfig, setDriverToConfig);\n\n        this._driverSet.then(callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function(driverName) {\n        return !!driverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    // Used to determine which driver we should use as the backend for this\n    // instance of localForage.\n    LocalForage.prototype._getFirstSupportedDriver = function(drivers) {\n        if (drivers && isArray(drivers)) {\n            for (var i = 0; i < drivers.length; i++) {\n                var driver = drivers[i];\n\n                if (this.supports(driver)) {\n                    return driver;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    LocalForage.prototype.createInstance = function(options) {\n        return new LocalForage(options);\n    };\n\n    // The actual localForage object that we expose as a module or via a\n    // global. It's extended by pulling in one of our other libraries.\n    var localForage = new LocalForage();\n\n    // We allow localForage to be declared as a module or as a library\n    // available without AMD/require.js.\n    if (moduleType === ModuleType.DEFINE) {\n        define('localforage', function() {\n            return localForage;\n        });\n    } else if (moduleType === ModuleType.EXPORT) {\n        module.exports = localForage;\n    } else {\n        this.localforage = localForage;\n    }\n}).call(window);\n","(function (global){\n\nvar rng;\n\nif (global.crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})","//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n","'use strict';\n\nvar async = require( 'async' );\nvar uuid = require( 'uuid' );\nvar localforage = require( 'localforage' );\n\nmodule.exports = {};\n\nvar STORAGE_KEY = 'ubid:signaturedata';\n\nmodule.exports.get = function( callback ) {\n    var storedIDChecked = false;\n    \n    function onFound( signatureJSON ) {\n        if ( storedIDChecked ) {\n            return;\n        }\n        \n        storedIDChecked = true;\n        \n        function handleSignatureData( error, signatureData ) {\n\n            if ( !error ) {\n                localforage.setItem( STORAGE_KEY, JSON.stringify( signatureData ) );\n            }\n            \n            if ( signatureData ) {\n                signatureData.localStorage = true;\n            }\n\n            callback( error, signatureData );\n        }\n        \n        if ( !signatureJSON ) {\n            getSignatureData( handleSignatureData );\n            return;\n        }\n        \n        try {\n            var signatureData = JSON.parse( signatureJSON );\n            signatureData.localStorage = true;\n            callback( null, signatureData );\n        }\n        catch( ex ) {\n            getSignatureData( handleSignatureData );\n        }\n    }\n\n    function onError() {\n        if ( storedIDChecked ) {\n            return;\n        }\n        \n        storedIDChecked = true;\n        getSignatureData( callback );\n    }\n    \n    localforage.getItem( STORAGE_KEY )\n        .then( onFound, onError )\n        .catch( onError );\n\n    // WORKAROUND FOR LOCALFORAGE BUG: when local storage is disabled, we get no callbacks, so handle it ourselves after 300ms\n    setTimeout( onError, 300 );    \n};\n\nfunction getSignatureData( callback ) {\n    var signatureData = {};\n    \n    async.parallel( [\n        getRandomID.bind( null, signatureData ),\n        getBrowserSignature.bind( null, signatureData ),\n        getCanvasSignature.bind( null, signatureData )\n    ], function( error ) {\n        callback( error, signatureData );\n    } );\n\n}\n\nfunction getRandomID( signatureData, callback ) {\n    signatureData.random = {\n        signature: uuid.v4()\n    };\n\n    callback();\n}\n\nfunction getBrowserSignature( signatureData, callback ) {\n    var idString = navigator.userAgent + navigator.language;\n    for ( var key in navigator.plugins ) {\n        var plugin = navigator.plugins[ key ];\n        idString += plugin.name + plugin.filename + plugin.description;\n    }\n\n    signatureData.browser = {\n        signature: SHA256( idString )\n    };\n    \n    callback();\n}\n\nvar CANVAS_TEXT = \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz 1234567890 !@#$%^&*()_-+=\";\nvar CANVAS_FONT_SIZE = 16;\nvar CANVAS_FONT_FACE = 'Arial';\nfunction getCanvasSignature( signatureData, callback ) {\n    // based on:\n    // https://www.browserleaks.com/canvas#how-does-it-work\n    // https://github.com/kmowery/canvas-fingerprinting\n    \n    signatureData.canvas = {};\n    \n    var canvas = document.createElement( 'canvas' );\n    if ( !canvas || !canvas.getContext ) {\n        signatureData.canvas.supported = false;\n        callback();\n        return;\n    }\n\n    var width = CANVAS_FONT_SIZE * ( CANVAS_TEXT.length + 2 );\n    var height = CANVAS_FONT_SIZE * 2;\n    canvas.setAttribute( 'width', width );\n    canvas.setAttribute( 'height', height );\n\n    var ctx = canvas.getContext( '2d' );\n    if ( !ctx || typeof( ctx.fillText ) !== 'function' ) {\n        signatureData.canvas.supported = false;\n        callback();\n        return;\n    }\n\n    signatureData.canvas.supported = true;\n    \n    ctx.font = CANVAS_FONT_SIZE + 'px \\'' + CANVAS_FONT_FACE + '\\'';\n    ctx.textBaseline = 'middle';\n    ctx.textAlign = 'center';\n\n    ctx.fillStyle = \"#f60\";\n    ctx.fillRect( ( ( 3 * width ) / 8 ), 0, width / 4, height );\n\n    ctx.fillStyle = \"#069\";\n    ctx.fillText( CANVAS_TEXT, width / 2, height / 2 );\n    ctx.fillStyle = \"rgba(102, 204, 0, 0.7)\";\n    ctx.fillText( CANVAS_TEXT, ( width / 2 ) + 2, ( height / 2 ) + 2 );\n\n    var base64png = canvas.toDataURL( 'image/png' );\n    signatureData.canvas.signature = SHA256( base64png );\n    callback();\n}\n\n\n/**\n*\n*  Secure Hash Algorithm (SHA256)\n*  http://www.webtoolkit.info/\n*\n*  Original code by Angel Marin, Paul Johnston.\n*\n**/\n\nvar HEX_TAB = \"0123456789abcdef\";\n\nfunction SHA256( data ) {\n\n    var chrsz   = 8;\n\n    function safe_add (x, y) {\n        var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n        return (msw << 16) | (lsw & 0xFFFF);\n    }\n\n    function s( X, n ) { return ( X >>> n ) | (X << (32 - n)); }\n    function r( X, n ) { return ( X >>> n ); }\n    function ch(x, y, z) { return ((x & y) ^ ((~x) & z)); }\n    function maj(x, y, z) { return ((x & y) ^ (x & z) ^ (y & z)); }\n    function sigma0256(x) { return (s(x, 2) ^ s(x, 13) ^ s(x, 22)); }\n    function sigma1256(x) { return (s(x, 6) ^ s(x, 11) ^ s(x, 25)); }\n    function gamma0256(x) { return (s(x, 7) ^ s(x, 18) ^ r(x, 3)); }\n    function gamma1256(x) { return (s(x, 17) ^ s(x, 19) ^ r(x, 10)); }\n\n    function core_sha256 (m, l) {\n        var K = new Array(0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2);\n        var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n        var W = new Array(64);\n        var a, b, c, d, e, f, g, h, i, j;\n        var T1, T2;\n\n        m[l >> 5] |= 0x80 << (24 - l % 32);\n        m[((l + 64 >> 9) << 4) + 15] = l;\n\n        for ( i = 0; i<m.length; i+=16 ) {\n            a = HASH[0];\n            b = HASH[1];\n            c = HASH[2];\n            d = HASH[3];\n            e = HASH[4];\n            f = HASH[5];\n            g = HASH[6];\n            h = HASH[7];\n\n            for ( j = 0; j<64; j++) {\n                if (j < 16) W[j] = m[j + i];\n                else W[j] = safe_add(safe_add(safe_add(gamma1256(W[j - 2]), W[j - 7]), gamma0256(W[j - 15])), W[j - 16]);\n\n                T1 = safe_add(safe_add(safe_add(safe_add(h, sigma1256(e)), ch(e, f, g)), K[j]), W[j]);\n                T2 = safe_add(sigma0256(a), maj(a, b, c));\n\n                h = g;\n                g = f;\n                f = e;\n                e = safe_add(d, T1);\n                d = c;\n                c = b;\n                b = a;\n                a = safe_add(T1, T2);\n            }\n\n            HASH[0] = safe_add(a, HASH[0]);\n            HASH[1] = safe_add(b, HASH[1]);\n            HASH[2] = safe_add(c, HASH[2]);\n            HASH[3] = safe_add(d, HASH[3]);\n            HASH[4] = safe_add(e, HASH[4]);\n            HASH[5] = safe_add(f, HASH[5]);\n            HASH[6] = safe_add(g, HASH[6]);\n            HASH[7] = safe_add(h, HASH[7]);\n        }\n        return HASH;\n    }\n\n    function str2binb (str) {\n        var bin = [];\n        var mask = (1 << chrsz) - 1;\n        for(var i = 0; i < str.length * chrsz; i += chrsz) {\n            bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - i%32);\n        }\n        return bin;\n    }\n\n    function utf8Encode(string) {\n        string = string.replace(/\\r\\n/g,\"\\n\");\n        var utftext = \"\";\n\n        for (var n = 0; n < string.length; n++) {\n\n            var c = string.charCodeAt(n);\n\n            if (c < 128) {\n                utftext += String.fromCharCode(c);\n            }\n            else if((c > 127) && (c < 2048)) {\n                utftext += String.fromCharCode((c >> 6) | 192);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n            else {\n                utftext += String.fromCharCode((c >> 12) | 224);\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128);\n                utftext += String.fromCharCode((c & 63) | 128);\n            }\n\n        }\n\n        return utftext;\n    }\n\n    function binb2hex (binarray) {\n        var str = \"\";\n        for(var i = 0; i < binarray.length * 4; i++) {\n            str += HEX_TAB.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n                HEX_TAB.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n        }\n        return str;\n    }\n\n    var utf = utf8Encode( data );\n    return binb2hex(core_sha256(str2binb(utf), utf.length * chrsz));\n}\n"],"sourceRoot":"/source/"}